работает потребляя ~85% CPU
- кол-во потоков для расчёта хэшей выбрано как N - 2
// - HashAlgorithm каждый создаётся для каждого блока, что не эффективно
// - синхронизации нет, т.е. при медленном чтении N-2 потока будут впустую постоянно пытаться получить что-то из очереди

по коду:
// - есть управление на exception-ах (EndСonveyorException)
- не обрабатываются exception-ы в CPU bound потоках 
// - проблемы с инкапсуляцией\абстракциями:
// - передаём извне очереди в HashСonveyor, хотя снаружи не используются
// - предоставляем наружу внуренности (hashСonveyors[currIndex].Blocks.Enqueue(block))

Хорошо, что выделен компонент HashConverter и внури он даже напрямую не пишет в stdout, но

- при ошибке метод Convert завершается успешно
- при написании самого компонента стоило отделить абстракциями высокоуровневую логику (читаем, считаем, пишем) от низкоуровневой (потоки, детали ). 
- делегаты и анонимные методы тоже не добавляют читаемости высокоуровневой логике. Как и одинаковое именование локальных переменных и мемберов.